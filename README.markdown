# autocache

Provides facilities for memozing function calls using pluggable cache backends.
Cache keys are (by default) automatically generated based on the function's
bytecode (along with the `*args`/`**kwargs` that the function receives).

## Features

* Easy to use decorator implementation
* Implicit versioning of cache keys based on generated bytecode
* Generation of cache keys from hashed argument values
* API compliant with [Django](https://docs.djangoproject.com/en/dev/topics/cache/)
  and [Flask](http://flask.pocoo.org/docs/patterns/caching/), and simple to
  create your own cache backends if your cache backend of choice is not already
  supported.

## Caveats

* Bytecode is not guaranteed to be the same between different interpreter
  versions or implementations (for example, Python 2.6 to 2.7, or CPython to
  PyPy.) In many cases the bytecode will be identical, but not always. Upgrading
  Python versions could result in a variation of the
  [thundering herd problem](http://en.wikipedia.org/wiki/Thundering_herd_problem).
* All arguments values must implement the `__hash__` method, and this method
  must be [deterministic](http://en.wikipedia.org/wiki/Deterministic_algorithm)
  between interpreter restarts, etc. *This makes it impossible to use lists or
  hashes as arguments to a cached function, unless you use a custom key
  generation function, or convert the values into a hashable type before calling
  the cache-wrapped function.*

## Installation

TODO

## Usage

### autocache.cached(backend, \*\*kwargs)

* **key:** use a user-defined cache key (not versioned) instead of hashing the
  function's bytecode
* **key_generator:** use a user-defined cache key generator instead of using
  `__hash__` on the args/kwargs passed to the callable
* **set_kwargs:** keyword arguments passed to the cache backend's `set` method,
  so you can pass timeouts, etc. when setting cached values

#### Example

For example, caching a function with Django's cache backend:

```python
from autocache import cached
from django.core.cache import cache

@cached(backend=cache)
def expensive_function(x):
    return x ** x

# This will be invoked, and the result will be stored in cache.
expensive_function(10)

# This will be served directly from cache.
expensive_function(10)

# This will be invoked, and the result will be stored in the cache
# as a new value (since `x=100` in this case)
expensive_function(100)
```

#### Using a user-defined base key

TODO - No implicit bytecode versioning

#### Using a user-defined key function

TODO - Make sure arguments are hashable, refactor out hashed tuple generation, etc

#### Passing additional keyword arguments when setting cache values

TODO - Providing cache timeout values, etc

### Writing your own cache backend

TODO

## Contributing

### Quickstart

    # optionally add "-p /usr/local/bin/pypy " argument if you have
    # pypy installed and want to use it
    virtualenv --no-site-packages autocache
    cd autocache
    echo "export PIP_RESPECT_VIRTUALENV=true" >> bin/activate
    source bin/activate
    git clone git://github.com/tkaemming/autocache.git repo
    cd repo

### Running tests

To run the test suite, run `make test` in the repository directory.

### Style guidelines

Please generally follow [PEP8](http://www.python.org/dev/peps/pep-0008/) style
if you are planning on submitting patches.

Before submitting a patch, please make sure that it passes both pyflakes tests
and PEP8 checks by running `make check`.

## License

MIT Licensed, see `LICENSE` for the full text.

## Authors

* Ted Kaemming: <https://github.com/tkaemming>
* Mike Tigas: <https://github.com/mtigas>
